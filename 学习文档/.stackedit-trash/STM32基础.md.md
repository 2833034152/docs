\# 前言 ST公司在2011年又推出基于Cortex M4内核的STM32F4系列产品，相对与STM32F1/F2等Cortex M3产品，STM32F4最大的优势，就是新增了硬件FPU单元以及DSP指令，同时，STM32F4的主频也提高了很多，达到168Mhz（可获得210DMIPS的处理能力），这使得STM32F4尤其适用于需要浮点运算或DSP处理的应用，也被称之为：DSC，具有非常广泛的应用前景。 STM32F4相对于STM32F1，主要优势如下： 1， 更先进的内核。STM32F4采用Cortex M4内核，带FPU和DSP指令集，而STM32F1采用的是Cortex M3内核，不带FPU和DSP指令集。 2， 更多的资源。STM32F4拥有多达192KB的片内SRAM，带摄像头接口（DCMI）、加密处理器（CRYP）、USB高速OTG、真随机数发生器、OTP存储器等。 3， 增强的外设功能。对于相同的外设部分，STM32F4具有更快的模数转换速度、更低的ADC/DAC工作电压、32位定时器、带日历功能的实时时钟（RTC）、IO复用功能大大增强、4K字节的电池备份SRAM以及更快的USART和SPI通信速度。 4， 更高的性能。STM32F4最高运行频率可达168Mhz，而STM32F1只能到72Mhz；STM32F4拥有ART自适应实时加速器，可以达到相当于FLASH零等待周期的性能，STM32F1则需要等待周期；STM32F4的FSMC采用32位多重AHB总线矩阵，相比STM32F1总线访问速度明显提高。 5， 更低的功耗。STM32F40x的功耗为：238uA/Mhz，其中低功耗版本的STM32F401更是低到：140uA/Mhz，而STM32F1则高达421uA/Mhz。 STM32F4家族目前拥有：STM32F40x、STM32F41x、STM32F42x和STM32F43x等几个系列，数十个产品型号，不同型号之间软件和引脚具有良好的兼容性，可方便客户迅速升级产品。其中，STM32F42x/43x系列带了LCD控制器和SDRAM接口，对于想要驱动大屏或需要大内存的朋友来说，是个不错的选择。目前STM32F4这些芯片型号都已量产，可以方便的购买到。 ## 实物图 !\[image-20221031155858245\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221031155858245.png) 按照功能分类： 主芯片： STM32f407 通信功能： 串口、IIC、SPI、CAN、USB口、以太网 存储功能：EEPROM、内部flash、SD卡 下载功能：JTAG、SWD 时间控制：晶振 显示模块：LCD、LED 转换：AD、DA 电压转化电路：DC 5V 转换成 DC 3.3V 外设再多，都有最简单的单片机最小系统！ 最小系统：使单片机可以正常工作的必要组成部分 包括： 电源电路： 复位、启动电路 振荡电路：对单片机至关重要！单片接的一切指令的执行都是建立在单片机晶振提供的时钟频率。单片机晶振提供的时钟频率越高，那么单片机运行速度就越快。 ## 硬件资源详解 1、 MC U （Micro Controllers Unit) ，又称单片机，是一个32位的微控制芯片 ALIENTEK 探索者 STM32F4 开发板 选择的是 STM32F407ZGT6 作为 MCU 该芯片是 STM32F407 里面配置 非常 强大的了， 它拥有的资源包括： 集成 FPU 和 DSP 指令，并具有 192KB SRAM 、 1024KB FLASH 、 12 个 16 位定时器、 2 个 32 位定时器、 2 个 DMA 控制器（共 16 个 通道）、 3 个 SPI 、 2 个全双工 I2S 、 3 个 IIC 、 6 个串口、 2 个 USB （支持 HOST /SLAVE ）、 2 个 CAN 、 3 个 12 位 ADC 、 2 个 12 位 DAC 、 1 个 RTC （带日历功能）、 1 个 SDIO 接口、 1 个 FSMC 接口、 1 个 10/100M 以太网 MAC 控制器、 1 个摄像头接口、 1 个硬件随机数生成器、以及 112 个通用 IO 口等 。 该芯片的配置十分强悍， 很多功能相对 STM32F1 来说进行了重大改进，比如 FSMC 的速度， F4 刷屏速度可达 3300W 像素 秒，而 F1 的速度则只有 500W 左右。 !\[image-20221031172738931\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221031172738931.png) ​ MCU 电路图 2、MUC通过输入输出接口 （ IO口 ）和外设相连： !\[image-20221031172637800\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221031172637800.png) ## GPIO ### 工作模式 1.输入浮空 2.输入上拉 3.输入下拉 4.模拟输入 5.开漏输出 6.推挽输出 7.推挽复用功能 8.开漏复用功能 博文详解：\[GPIO的工作模式\](https://yngzmiao.blog.csdn.net/article/details/79858906?spm=1001.2101.3001.6661.1&utm\_medium=distribute.pc\_relevant\_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-79858906-blog-124661955.pc\_relevant\_vip\_default&depth\_1-utm\_source=distribute.pc\_relevant\_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-79858906-blog-124661955.pc\_relevant\_vip\_default&utm\_relevant\_index=1) ### 寄存器 分别对应着8个寄存器： MODER 、 OTYPER 、 OSPEEDR 、 PUPDR 、 O DR 、 IDR 、 AFRH 和 AFRL 。 #### GPIO端口模式寄存器：MODER !\[image-20221101174740205\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221101174740205.png) 代码控制： GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_OUT;//普通输出模式 #### 上下拉寄存器 !\[image-20221101174853779\](C:\\Users\\kxliu\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221101174853779.png) GPIO\_InitStructure.GPIO\_PuPd = GPIO\_PuPd\_UP;//上拉 ## 时钟 因为STM32的外设非常多，本身非常复杂，外设非常的多，但是并不是所有外设都需要系统时钟这么高的频率，比如看门狗以及 RTC 只需要几十 k 的时钟即可。同一个电路，时钟越快功耗越大，同时抗电磁干扰能力也会越弱，所以对于较为复杂的 MCU 一般都是采取多时钟源的方法来解决这些问题。 ### 时钟树 !\[image-20221101152143011\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221101152143011.png) ### 时钟源 5个时钟源：LSE、LSI、HSE、HSI、PLL ① LSI 是低速内部时钟，频率为 32 kHz 左右 。 供独立看门狗和自动唤醒单元使用。 ② LSI: (low speed internal clock signal) 低速内部时钟 ③ HSE ：（high speed external clock signal)：高速外部时钟 ，外接8M的晶振 。HSE 也可以直接做为系统时钟或者 PLL 输入。 比如 ，D处 可以看出， SYSCLK 系统时钟来源有三个方面：HSI,HSE 和 PLL。 当HSE出现故障时，HSI作为系统内部的备用时钟，直到HSE恢复正常。 ④ HSI：高速内部时钟。 ⑤ PLL 为锁相环倍频 输出 ### 常用时钟源 SYSCLK （系统时钟 168 MHz AHB 总线时钟 HCLK=SYSCLK ) 168 MHz APB1 总线时钟 (PCLK1 =SYSCLK/4 ) 42 MHz APB2 总线时钟 (PCLK2 =SYSCLK/2 ) 84 MHz PLL 主 时钟 =168 MHz ### 外设使用的时钟 如果使用具体的外设需要设置哪个时钟呢？ 1、AHB总线： （1）Flash 存储器； （2）DMA； （3）复位和时钟控制； （4）CRC; （5）以太⽹； （6）SDIO； 2、APB2总线： （1）USART1； （2）⾼级控制定时器TIM1和TIM8； （3）模数转换器ADC1、ADC2、ADC3； （4）SPI1； （5）外部中断EXTI； （6）复⽤IO，AFIO； （7）通⽤IO：GPIOA~G； 3、APB1总线： （1）定时器TIM2到TIM7； （2）RTC； （3）WDT看门狗； （4）SPI2 、SPI3； （5）USART2、USART3； （6）UART4、UART5； （7）IIC1，IIC2； （8）USB./CAN共享的512字节SRAM； （9）bXCAN1、bXCAN2； （10）后备寄存器BKP； （11）电源控制PWR； （12）DAC ### 相关函数 配置系统时钟sysclk的时钟源： void RCC\_SYSCLKConfig(uint32\_t RCC\_SYSCLKSource); 复位： void RCC\_AHB1PeriphResetCmd(uint32\_t RCC\_AHB1Periph, FunctionalState NewState); 时钟使能函数： void RCC\_AHB1PeriphClockCmd(uint32\_t RCC\_AHB1Periph, FunctionalState NewState); void RCC\_HSICmd(FunctionalState NewState); 函数的底层都是操作寄存器完成的，和时钟相关的寄存器： RCC 时钟控制寄存器： RCC\_CR RCC PLL控制寄存器: RCC\_PLLCFGR RCC 时钟配置寄存器： RCC\_CFGR RCC AHB1外设复位寄存器：RCC\_AHB1RSTR ### RCC AHB1外设时钟使能寄存器 !\[image-20221102160450956\](C:\\Users\\kxliu\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221102160450956.png) ### RCC APB1外设时钟使能寄存器 !\[image-20221102160235011\](C:\\Users\\kxliu\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221102160235011.png) ## 中断 ### 中断的作用 STM32 的每个外设都可以产生中断，NVIC时嵌套向量中断控制器，控制这整个芯片中断相关的功能，是内核里面的一个外设。 什么情况下产生中断？ STM32中断包含EXTI外部中断，TIM定时中断，ADC数模中断，USART串口中断，SPI通讯中断，IIC通讯中断，RTC实时时钟等多个外设中断。 ### NVIC（Nested Vectored Interrupt Contrlller)常用寄存器简介 ISER 中断使能寄存器 ICER：失能中断 IPR：中断优先级寄存器 ### 优先级 !\[image-20221102152438654\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221102152438654.png) ​ 8位IPR 用于表达优先级的4位又被分位抢占优先级（主优先级）和子优先级，这两个优先级各占几位又要根据SCB->AIRCR中的中断分组决定。如果有多个中断同时响应，先比较抢占优先级，再比较子优先级，值越低，优先级越高，如果两者都相同，就比较它们的硬件编号，也是号越小，优先级越高。 !\[image-20221102154741988\](C:\\Users\\kxliu\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221102154741988.png) !\[image-20221102154842971\](C:\\Users\\kxliu\\AppData\\Roaming\\Typora\\typora-user-images\\image-20221102154842971.png) ### NVIC固件库中的函数

NVIC库函数

描述

void NVIC\_EnalbeIRQ(IRQn\_Type IRQn);

使能中断

void NVIC\_SetPendingIRQ(IRQ\_Type IRQn);

设置中断悬起位

void NVIC\_ClearPendingIQR(IRQ\_Type IRQn);

清除中断悬起位

void NVIC\_SetPriority(IRQn\_Type IQRn, uint32\_t priority);

设置中断优先级

uint32\_t NVIC\_GetPriority(IRQn\_Type IQRn, uint32\_t priority);

获取中断优先级

void NVIC\_SystemReset(void);

系统复位

​ 这些函数编程时用的较少，一般直接使用以下方法即可： ​ NVIC\_InitStructure.NVIC\_IRQChannel = USART1\_IRQn;//串口1中断通道 ​ NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority=3;//抢占优先级3 ​ NVIC\_InitStructure.NVIC\_IRQChannelSubPriority =3; //子优先级3 ​ NVIC\_InitStructure.NVIC\_IRQChannelCmd = ENABLE; //IRQ通道使能 ​ NVIC\_Init(&NVIC\_InitStructure); //根据指定的参数初始化VIC寄存器 ## 外部中断使用范例： EXIT中断可以控制的中断类型： !\[image-20221107165647749\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221107165647749.png) 外部中断/事件控制器框图： !\[image-20221107163722525\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221107163722525.png) 功能：但是这里我们使用的是中断来检测按键，还是 KEY\_UP 控制 蜂鸣器，按一次叫，再按一次停； KEY 2 控制 DS 0 按一次亮，再按一次灭； KEY1 控制 DS1 ，效果同 KEY2 KEY 0 则 同时控制 DS0 和 DS1 ，按一次，他们的状态就翻转一次。 !\[image-20221107105903072\](https://typora-bucket-1304106066.cos.ap-shanghai.myqcloud.com/typoraimage-20221107105903072.png) ### 配置文件：key.c ~~~c #include "exti.h" #include "delay.h" #include "led.h" #include "key.h" #include "beep.h" //按键初始化函数 void KEY\_Init(void) { GPIO\_InitTypeDef GPIO\_InitStructure; RCC\_AHB1PeriphClockCmd(RCC\_AHB1Periph\_GPIOA|RCC\_AHB1Periph\_GPIOE, ENABLE);//使能GPIOA,GPIOE时钟 GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_2|GPIO\_Pin\_3|GPIO\_Pin\_4; //KEY0 KEY1 KEY2对应引脚 GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_IN;//普通输入模式 GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_100MHz;//100M GPIO\_InitStructure.GPIO\_PuPd = GPIO\_PuPd\_UP;//上拉 GPIO\_Init(GPIOE, &GPIO\_InitStructure);//初始化GPIOE2,3,4 GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_0;//WK\_UP对应引脚PA0 GPIO\_InitStructure.GPIO\_PuPd = GPIO\_PuPd\_DOWN ;//下拉 GPIO\_Init(GPIOA, &GPIO\_InitStructure);//初始化GPIOA0 } //外部中断0服务程序 void EXTI0\_IRQHandler(void) { delay\_ms(10); //消抖 if(WK\_UP==1) { BEEP=!BEEP; //蜂鸣器翻转 } EXTI\_ClearITPendingBit(EXTI\_Line0); //清除LINE0上的中断标志位 } //外部中断2服务程序 void EXTI2\_IRQHandler(void) { delay\_ms(10); //消抖 if(KEY2==0) { LED0=!LED0; } EXTI\_ClearITPendingBit(EXTI\_Line2);//清除LINE2上的中断标志位 } //外部中断3服务程序 void EXTI3\_IRQHandler(void) { delay\_ms(10); //消抖 if(KEY1==0) { LED1=!LED1; } EXTI\_ClearITPendingBit(EXTI\_Line3); //清除LINE3上的中断标志位 } //外部中断4服务程序 void EXTI4\_IRQHandler(void) { delay\_ms(10); //消抖 if(KEY0==0) { LED0=!LED0; LED1=!LED1; } EXTI\_ClearITPendingBit(EXTI\_Line4);//清除LINE4上的中断标志位 } //外部中断初始化程序 //初始化PE2~4,PA0为中断输入. void EXTIX\_Init(void) { NVIC\_InitTypeDef NVIC\_InitStructure; EXTI\_InitTypeDef EXTI\_InitStructure; KEY\_Init(); //按键对应的IO口初始化 RCC\_APB2PeriphClockCmd(RCC\_APB2Periph\_SYSCFG, ENABLE);//使能SYSCFG时钟 SYSCFG\_EXTILineConfig(EXTI\_PortSourceGPIOE, EXTI\_PinSource2);//PE2 连接到中断线2 SYSCFG\_EXTILineConfig(EXTI\_PortSourceGPIOE, EXTI\_PinSource3);//PE3 连接到中断线3 SYSCFG\_EXTILineConfig(EXTI\_PortSourceGPIOE, EXTI\_PinSource4);//PE4 连接到中断线4 SYSCFG\_EXTILineConfig(EXTI\_PortSourceGPIOA, EXTI\_PinSource0);//PA0 连接到中断线0 /\* 配置EXTI\_Line0 \*/ EXTI\_InitStructure.EXTI\_Line = EXTI\_Line0;//LINE0 EXTI\_InitStructure.EXTI\_Mode = EXTI\_Mode\_Interrupt;//中断事件 EXTI\_InitStructure.EXTI\_Trigger = EXTI\_Trigger\_Rising; //上升沿触发 EXTI\_InitStructure.EXTI\_LineCmd = ENABLE;//使能LINE0 EXTI\_Init(&EXTI\_InitStructure);//配置 /\* 配置EXTI\_Line2,3,4 \*/ EXTI\_InitStructure.EXTI\_Line = EXTI\_Line2 | EXTI\_Line3 | EXTI\_Line4; EXTI\_InitStructure.EXTI\_Mode = EXTI\_Mode\_Interrupt;//中断事件 EXTI\_InitStructure.EXTI\_Trigger = EXTI\_Trigger\_Falling; //下降沿触发 EXTI\_InitStructure.EXTI\_LineCmd = ENABLE;//中断线使能 EXTI\_Init(&EXTI\_InitStructure);//配置 NVIC\_InitStructure.NVIC\_IRQChannel = EXTI0\_IRQn;//外部中断0 NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority = 0x00;//抢占优先级0 NVIC\_InitStructure.NVIC\_IRQChannelSubPriority = 0x02;//子优先级2 NVIC\_InitStructure.NVIC\_IRQChannelCmd = ENABLE;//使能外部中断通道 NVIC\_Init(&NVIC\_InitStructure);//配置 NVIC\_InitStructure.NVIC\_IRQChannel = EXTI2\_IRQn;//外部中断2 NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority = 0x03;//抢占优先级3 NVIC\_InitStructure.NVIC\_IRQChannelSubPriority = 0x02;//子优先级2 NVIC\_InitStructure.NVIC\_IRQChannelCmd = ENABLE;//使能外部中断通道 NVIC\_Init(&NVIC\_InitStructure);//配置 NVIC\_InitStructure.NVIC\_IRQChannel = EXTI3\_IRQn;//外部中断3 NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority = 0x02;//抢占优先级2 NVIC\_InitStructure.NVIC\_IRQChannelSubPriority = 0x02;//子优先级2 NVIC\_InitStructure.NVIC\_IRQChannelCmd = ENABLE;//使能外部中断通道 NVIC\_Init(&NVIC\_InitStructure);//配置 NVIC\_InitStructure.NVIC\_IRQChannel = EXTI4\_IRQn;//外部中断4 NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority = 0x01;//抢占优先级1 NVIC\_InitStructure.NVIC\_IRQChannelSubPriority = 0x02;//子优先级2 NVIC\_InitStructure.NVIC\_IRQChannelCmd = ENABLE;//使能外部中断通道 NVIC\_Init(&NVIC\_InitStructure);//配置 } ~~~ ### 应用层程序：main.c ~~~c #include "sys.h" #include "delay.h" #include "usart.h" #include "led.h" #include "beep.h" #include "key.h" #include "exti.h" int main(void) { NVIC\_PriorityGroupConfig(NVIC\_PriorityGroup\_2);//设置系统中断优先级分组2 delay\_init(168); //初始化延时函数 uart\_init(115200); //串口初始化 LED\_Init(); //初始化LED端口 BEEP\_Init(); //初始化蜂鸣器端口 EXTIX\_Init(); //初始化外部中断输入 LED0=0; //先点亮红灯 while(1) { printf("OK\\r\\n"); //打印OK提示程序运行 delay\_ms(1000); //每隔1s打印一次 } } ~~~ ## 串口通信的范例代码 ### 串口配置文件：usart.c ~~~c void usart\_init(u32 bound){ //GPIO端口设置 GPIO\_InitTypeDef GPIO\_InitStructure; USART\_InitTypeDef USART\_InitStructure; NVIC\_InitTypeDef NVIC\_InitStructure; RCC\_AHB1PeriphClockCmd(RCC\_AHB1Periph\_GPIOA,ENABLE); //使能GPIOA时钟 RCC\_APB2PeriphClockCmd(RCC\_APB2Periph\_USART1,ENABLE);//使能USART1时钟 //串口1对应引脚复用映射 GPIO\_PinAFConfig(GPIOA,GPIO\_PinSource9,GPIO\_AF\_USART1); //GPIOA9复用为USART1 GPIO\_PinAFConfig(GPIOA,GPIO\_PinSource10,GPIO\_AF\_USART1); //GPIOA10复用为USART1 //USART1端口配置 GPIO\_InitStructure.GPIO\_Pin = GPIO\_Pin\_9 | GPIO\_Pin\_10; //GPIOA9与GPIOA10 GPIO\_InitStructure.GPIO\_Mode = GPIO\_Mode\_AF;//复用功能 GPIO\_InitStructure.GPIO\_Speed = GPIO\_Speed\_50MHz; //速度50MHz GPIO\_InitStructure.GPIO\_OType = GPIO\_OType\_PP; //推挽复用输出 GPIO\_InitStructure.GPIO\_PuPd = GPIO\_PuPd\_UP; //上拉 GPIO\_Init(GPIOA,&GPIO\_InitStructure); //初始化PA9，PA10 //USART1 初始化设置 USART\_InitStructure.USART\_BaudRate = bound;//波特率设置 USART\_InitStructure.USART\_WordLength = USART\_WordLength\_8b;//字长为8位数据格式 USART\_InitStructure.USART\_StopBits = USART\_StopBits\_1;//一个停止位 USART\_InitStructure.USART\_Parity = USART\_Parity\_No;//无奇偶校验位 USART\_InitStructure.USART\_HardwareFlowControl = USART\_HardwareFlowControl\_None;//无硬件数据流控制 USART\_InitStructure.USART\_Mode = USART\_Mode\_Rx | USART\_Mode\_Tx; //收发模式 USART\_Init(USART1, &USART\_InitStructure); //初始化串口1 USART\_Cmd(USART1, ENABLE); //使能串口1 //USART\_ClearFlag(USART1, USART\_FLAG\_TC); #if EN\_USART1\_RX USART\_ITConfig(USART1, USART\_IT\_RXNE, ENABLE);//开启相关中断 //Usart1 NVIC 配置 NVIC\_InitStructure.NVIC\_IRQChannel = USART1\_IRQn;//串口1中断通道 NVIC\_InitStructure.NVIC\_IRQChannelPreemptionPriority=3;//抢占优先级3 NVIC\_InitStructure.NVIC\_IRQChannelSubPriority =3; //子优先级3 NVIC\_InitStructure.NVIC\_IRQChannelCmd = ENABLE; //IRQ通道使能 NVIC\_Init(&NVIC\_InitStructure); //根据指定的参数初始化VIC寄存器、 #endif } void USART1\_IRQHandler(void) //串口1中断服务程序 { u8 Res; #if SYSTEM\_SUPPORT\_OS //如果SYSTEM\_SUPPORT\_OS为真，则需要支持OS. OSIntEnter(); #endif if(USART\_GetITStatus(USART1, USART\_IT\_RXNE) != RESET) //接收中断(接收到的数据必须是0x0d 0x0a结尾) { Res =USART\_ReceiveData(USART1);//(USART1->DR); //读取接收到的数据 if((USART\_RX\_STA&0x8000)==0)//接收未完成 { if(USART\_RX\_STA&0x4000)//接收到了0x0d { if(Res!=0x0a)USART\_RX\_STA=0;//接收错误,重新开始 else USART\_RX\_STA|=0x8000; //接收完成了 } else //还没收到0X0D { if(Res==0x0d)USART\_RX\_STA|=0x4000; else { USART\_RX\_BUF\[USART\_RX\_STA&0X3FFF\]=Res ; USART\_RX\_STA++; if(USART\_RX\_STA>(USART\_REC\_LEN-1))USART\_RX\_STA=0;//接收数据错误,重新开始接收 } } } } #if SYSTEM\_SUPPORT\_OS //如果SYSTEM\_SUPPORT\_OS为真，则需要支持OS. OSIntExit(); #endif } ~~~ ### 应用层代码 ：main.c ~~~c #include "sys.h" #include "delay.h" #include "usart.h" #include "led.h" #include "beep.h" #include "key.h" #include "stdio.h" int main(void) { u8 t; u8 len; u16 times=0; NVIC\_PriorityGroupConfig(NVIC\_PriorityGroup\_2);//设置系统中断优先级分组2 delay\_init(168); //延时初始化 uart\_init(115200); //串口初始化波特率为115200 LED\_Init(); //初始化与LED连接的硬件接口 while(1) { if(USART\_RX\_STA&0x8000) { len=USART\_RX\_STA&0x3fff;//得到此次接收到的数据长度 printf("\\r\\n您发送的消息为:\\r\\n"); for(t=0;t
<!--stackedit_data:
eyJoaXN0b3J5IjpbODgyOTM2MzU3XX0=
-->